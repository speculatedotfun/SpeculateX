{
  "language": "Solidity",
  "sources": {
    "ChainlinkResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.24;\\n\\n// src/interfaces/AggregatorV3Interface.sol\\n\\n/**\\n * @title AggregatorV3Interface\\n * @notice Chainlink Price Feed Interface\\n */\\ninterface AggregatorV3Interface {\\n    function decimals() external view returns (uint8);\\n    \\n    function description() external view returns (string memory);\\n    \\n    function version() external view returns (uint256);\\n\\n    function getRoundData(uint80 _roundId)\\n        external\\n        view\\n        returns (\\n            uint80 roundId,\\n            int256 answer,\\n            uint256 startedAt,\\n            uint256 updatedAt,\\n            uint80 answeredInRound\\n        );\\n\\n    function latestRoundData()\\n        external\\n        view\\n        returns (\\n            uint80 roundId,\\n            int256 answer,\\n            uint256 startedAt,\\n            uint256 updatedAt,\\n            uint80 answeredInRound\\n        );\\n}\\n\\n// src/interfaces/AutomationCompatibleInterface.sol\\n\\n/**\\n * @notice Chainlink Automation Compatible Interface\\n * @dev https://docs.chain.link/chainlink-automation/compatible-contracts\\n */\\ninterface AutomationCompatibleInterface {\\n    /**\\n     * @notice Checks if upkeep is needed\\n     * @param checkData Encoded data to perform the check\\n     * @return upkeepNeeded Whether upkeep is needed\\n     * @return performData Encoded data to perform the upkeep\\n     */\\n    function checkUpkeep(bytes calldata checkData)\\n        external\\n        view\\n        returns (bool upkeepNeeded, bytes memory performData);\\n\\n    /**\\n     * @notice Performs the upkeep\\n     * @param performData Encoded data to perform the upkeep\\n     */\\n    function performUpkeep(bytes calldata performData) external;\\n}\\n\\n// lib/openzeppelin-contracts/contracts/utils/Context.sol\\n\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n\\n// lib/openzeppelin-contracts/contracts/access/IAccessControl.sol\\n\\n// OpenZeppelin Contracts (last updated v5.4.0) (access/IAccessControl.sol)\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC-165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev The `account` is missing a role.\\n     */\\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\\n\\n    /**\\n     * @dev The caller of a function is not the expected one.\\n     *\\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\\n     */\\n    error AccessControlBadConfirmation();\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted to signal this.\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call. This account bears the admin role (for the granted role).\\n     * Expected in cases where the role was granted using the internal {AccessControl-_grantRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `callerConfirmation`.\\n     */\\n    function renounceRole(bytes32 role, address callerConfirmation) external;\\n}\\n\\n// lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\\n\\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/IERC165.sol)\\n\\n/**\\n * @dev Interface of the ERC-165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\\n// lib/openzeppelin-contracts/contracts/utils/ReentrancyGuard.sol\\n\\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\\n * consider using {ReentrancyGuardTransient} instead.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant NOT_ENTERED = 1;\\n    uint256 private constant ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    /**\\n     * @dev Unauthorized reentrant call.\\n     */\\n    error ReentrancyGuardReentrantCall();\\n\\n    constructor() {\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\\n        if (_status == ENTERED) {\\n            revert ReentrancyGuardReentrantCall();\\n        }\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == ENTERED;\\n    }\\n}\\n\\n// lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol\\n\\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/ERC165.sol)\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n */\\nabstract contract ERC165 is IERC165 {\\n    /// @inheritdoc IERC165\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\\n// lib/openzeppelin-contracts/contracts/utils/Pausable.sol\\n\\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/Pausable.sol)\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    bool private _paused;\\n\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    /**\\n     * @dev The operation failed because the contract is paused.\\n     */\\n    error EnforcedPause();\\n\\n    /**\\n     * @dev The operation failed because the contract is not paused.\\n     */\\n    error ExpectedPause();\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        if (paused()) {\\n            revert EnforcedPause();\\n        }\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        if (!paused()) {\\n            revert ExpectedPause();\\n        }\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\\n// lib/openzeppelin-contracts/contracts/access/AccessControl.sol\\n\\n// OpenZeppelin Contracts (last updated v5.4.0) (access/AccessControl.sol)\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```solidity\\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```solidity\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\\n * to enforce additional security measures for this role.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address account => bool) hasRole;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 role => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    /// @inheritdoc IERC165\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\\n        return _roles[role].hasRole[account];\\n    }\\n\\n    /**\\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\\n     * is missing `role`.\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!hasRole(role, account)) {\\n            revert AccessControlUnauthorizedAccount(account, role);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `callerConfirmation`.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\\n        if (callerConfirmation != _msgSender()) {\\n            revert AccessControlBadConfirmation();\\n        }\\n\\n        _revokeRole(role, callerConfirmation);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\\n        if (!hasRole(role, account)) {\\n            _roles[role].hasRole[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Attempts to revoke `role` from `account` and returns a boolean indicating if `role` was revoked.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\\n        if (hasRole(role, account)) {\\n            _roles[role].hasRole[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n\\n// src/ChainlinkResolver.sol\\n\\ninterface ICoreResolutionView {\\n    enum OracleType { None, ChainlinkFeed }\\n    struct ResolutionConfig {\\n        uint256 startTime;      // When trading becomes active (0 = immediate)\\n        uint256 expiryTimestamp;\\n        OracleType oracleType;\\n        address oracleAddress;\\n        bytes32 priceFeedId;\\n        uint256 targetValue;\\n        uint8 comparison; // Comparison enum (not used here)\\n        bool yesWins;\\n        bool isResolved;\\n        uint8 oracleDecimals;\\n    }\\n    function getMarketResolution(uint256 id) external view returns (ResolutionConfig memory);\\n    function resolveMarketWithPrice(uint256 id, uint256 price) external;\\n    function marketCount() external view returns (uint256);\\n}\\n\\ncontract ChainlinkResolver is AccessControl, ReentrancyGuard, Pausable, AutomationCompatibleInterface {\\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\\n\\n    uint256 public timelockDelay = 24 hours;\\n    uint256 public maxStaleness  = 2 hours; // kept for backward compatibility / future use\\n    uint256 public opNonce;\\n\\n    address public core;\\n\\n    enum OpStatus { None, Scheduled, Executed, Cancelled }\\n    struct Op {\\n        bytes32 tag;\\n        bytes32 dataHash;\\n        uint256 readyAt;\\n        OpStatus status;\\n    }\\n    mapping(bytes32 => Op) public ops;\\n\\n    bytes32 public constant OP_SET_CORE      = keccak256(\"OP_SET_CORE\");\\n    bytes32 public constant OP_SET_STALENESS = keccak256(\"OP_SET_STALENESS\");\\n    bytes32 public constant OP_SET_DELAY     = keccak256(\"OP_SET_DELAY\");\\n    bytes32 public constant OP_PAUSE         = keccak256(\"OP_PAUSE\");\\n    bytes32 public constant OP_UNPAUSE       = keccak256(\"OP_UNPAUSE\");\\n\\n    event OpScheduled(bytes32 indexed opId, bytes32 indexed tag, uint256 readyAt);\\n    event OpExecuted(bytes32 indexed opId);\\n    event OpCancelled(bytes32 indexed opId);\\n\\n    event CoreUpdated(address indexed newCore);\\n    event MaxStalenessUpdated(uint256 newMaxStaleness);\\n    event TimelockDelayUpdated(uint256 newDelay);\\n\\n    event MarketResolved(uint256 indexed marketId, address indexed feed, uint256 price, uint256 updatedAt);\\n    event MarketResolvedTwap(uint256 indexed marketId, address indexed feed, uint256 twapPrice, uint256 windowStart, uint256 windowEnd);\\n    event MarketResolvedLate(uint256 indexed marketId, address indexed feed, uint256 updatedAt);\\n\\n    error ZeroAddress();\\n    error BadValue();\\n    error OpInvalid();\\n    error OpNotReady(uint256 readyAt);\\n    error TagMismatch();\\n    error DataMismatch();\\n    error OpExpired();\\n\\n    error NotChainlinkMarket();\\n    error FeedMissing();\\n    error InvalidAnswer();\\n    error Stale(uint256 updatedAt, uint256 nowTs, uint256 maxStale);\\n    error OracleDecimalsMismatch(uint8 expected, uint8 got);\\n    error MarketNotExpired();\\n    error RoundTooEarly(uint256 updatedAt, uint256 expiry);\\n    error NotFirstRoundAfterExpiry(uint256 prevUpdatedAt, uint256 expiry);\\n    error IncompleteRound();\\n    error UnsupportedDecimals();\\n    error InvalidRoundId();\\n    error PhaseBoundaryRound(); // cannot safely compute prev round id (occurs at round 0 or 1, or during phase transitions - rare edge case)\\n\\n    uint256 public constant MIN_TIMELOCK = 24 hours;\\n    uint256 public constant OP_EXPIRY_WINDOW = 7 days;\\n\\n    // =========================\\n    // Resolution policy knobs\\n    // =========================\\n    // SLA: resolve using FIRST Chainlink update after expiry if it arrives within this window\\n    uint256 public constant RESOLVE_SLA = 5 minutes;\\n\\n    // TWAP fallback window: [expiry, expiry + TWAP_WINDOW]\\n    uint256 public constant TWAP_WINDOW = 5 minutes;\\n\\n    // Lookback limits\\n    uint256 public constant MAX_LOOKBACK_FIRST = 96;\\n    uint256 public constant MAX_LOOKBACK_TWAP  = 256;\\n\\n    constructor(address admin, address core_) {\\n        if (admin == address(0) || core_ == address(0)) revert ZeroAddress();\\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\\n        _grantRole(ADMIN_ROLE, admin);\\n        core = core_;\\n    }\\n\\n    function scheduleOp(bytes32 tag, bytes calldata data) external onlyRole(ADMIN_ROLE) returns (bytes32 opId) {\\n        uint256 nonce_ = ++opNonce;\\n        opId = keccak256(abi.encode(\"RESOLVER_OP_V1\", tag, keccak256(data), nonce_));\\n        if (ops[opId].status != OpStatus.None) revert OpInvalid();\\n\\n        ops[opId] = Op({\\n            tag: tag,\\n            dataHash: keccak256(data),\\n            readyAt: block.timestamp + timelockDelay,\\n            status: OpStatus.Scheduled\\n        });\\n\\n        emit OpScheduled(opId, tag, ops[opId].readyAt);\\n    }\\n\\n    function _consume(bytes32 opId, bytes32 tag, bytes memory data) internal {\\n        Op storage op = ops[opId];\\n        if (op.status != OpStatus.Scheduled) revert OpInvalid();\\n        if (block.timestamp < op.readyAt) revert OpNotReady(op.readyAt);\\n        if (block.timestamp > op.readyAt + OP_EXPIRY_WINDOW) revert OpExpired();\\n        if (op.tag != tag) revert TagMismatch();\\n        if (op.dataHash != keccak256(data)) revert DataMismatch();\\n        op.status = OpStatus.Executed;\\n        emit OpExecuted(opId);\\n    }\\n\\n    function executeSetCore(bytes32 opId, address newCore) external onlyRole(ADMIN_ROLE) {\\n        if (newCore == address(0)) revert ZeroAddress();\\n        bytes memory data = abi.encode(newCore);\\n        _consume(opId, OP_SET_CORE, data);\\n        core = newCore;\\n        emit CoreUpdated(newCore);\\n    }\\n\\n    function executeSetMaxStaleness(bytes32 opId, uint256 newMax) external onlyRole(ADMIN_ROLE) {\\n        if (newMax == 0) revert BadValue();\\n        bytes memory data = abi.encode(newMax);\\n        _consume(opId, OP_SET_STALENESS, data);\\n        maxStaleness = newMax;\\n        emit MaxStalenessUpdated(newMax);\\n    }\\n\\n    function executeSetDelay(bytes32 opId, uint256 newDelay) external onlyRole(ADMIN_ROLE) {\\n        if (newDelay < MIN_TIMELOCK) revert BadValue();\\n        bytes memory data = abi.encode(newDelay);\\n        _consume(opId, OP_SET_DELAY, data);\\n        timelockDelay = newDelay;\\n        emit TimelockDelayUpdated(newDelay);\\n    }\\n\\n    function executePause(bytes32 opId) external onlyRole(ADMIN_ROLE) {\\n        _consume(opId, OP_PAUSE, \"\");\\n        _pause();\\n    }\\n\\n    function executeUnpause(bytes32 opId) external onlyRole(ADMIN_ROLE) {\\n        _consume(opId, OP_UNPAUSE, \"\");\\n        _unpause();\\n    }\\n\\n    function cancelOp(bytes32 opId) external onlyRole(ADMIN_ROLE) {\\n        Op storage op = ops[opId];\\n        if (op.status != OpStatus.Scheduled) revert OpInvalid();\\n        op.status = OpStatus.Cancelled;\\n        emit OpCancelled(opId);\\n    }\\n\\n    /**\\n     * @notice Parse composite Chainlink round ID into phase and aggregator round\\n     * @dev Chainlink uses composite IDs: phaseId (upper 16 bits) | aggregatorRoundId (lower 64 bits)\\n     */\\n    function parseRoundId(uint80 roundId) internal pure returns (uint16 phaseId, uint64 aggregatorRoundId) {\\n        phaseId = uint16(roundId >> 64);\\n        aggregatorRoundId = uint64(roundId);\\n    }\\n\\n    // =========================\\n    // Automation\\n    // =========================\\n\\n    /**\\n     * @notice Chainlink Automation: Check if upkeep is needed\\n     * @param checkData Encoded marketId (uint256) - if empty, searches first N markets\\n     * @return upkeepNeeded Whether upkeep is needed\\n     * @return performData Encoded marketId if upkeep is needed\\n     */\\n    function checkUpkeep(bytes calldata checkData)\\n        external\\n        view\\n        override\\n        returns (bool upkeepNeeded, bytes memory performData)\\n    {\\n        // If checkData is provided, check specific market\\n        if (checkData.length >= 32) {\\n            uint256 marketId = abi.decode(checkData, (uint256));\\n            return _checkSingleMarket(marketId);\\n        }\\n\\n        // Search for first market that needs resolution (limit to 50 to keep checkUpkeep cheap)\\n        uint256 maxMarketsToCheck = 50;\\n        uint256 totalMarkets = ICoreResolutionView(core).marketCount();\\n        uint256 endId = totalMarkets > maxMarketsToCheck ? maxMarketsToCheck : totalMarkets;\\n\\n        for (uint256 i = 1; i <= endId; i++) {\\n            (bool needed, bytes memory data) = _checkSingleMarket(i);\\n            if (needed) return (true, data);\\n        }\\n\\n        return (false, \"\");\\n    }\\n\\n    function _checkSingleMarket(uint256 marketId)\\n        internal\\n        view\\n        returns (bool upkeepNeeded, bytes memory performData)\\n    {\\n        ICoreResolutionView.ResolutionConfig memory r;\\n        try ICoreResolutionView(core).getMarketResolution(marketId) returns (ICoreResolutionView.ResolutionConfig memory config) {\\n            r = config;\\n        } catch {\\n            return (false, \"\");\\n        }\\n\\n        if (r.isResolved) return (false, \"\");\\n        if (block.timestamp < r.expiryTimestamp) return (false, \"\");\\n\\n        // Chainlink market detection (includes your workaround)\\n        bool isChainlink = (r.oracleType == ICoreResolutionView.OracleType.ChainlinkFeed) ||\\n            (r.priceFeedId != bytes32(0) && (r.oracleAddress == address(0) || r.oracleAddress == address(1)));\\n        if (!isChainlink) return (false, \"\");\\n\\n        address feedAddress = r.oracleAddress;\\n        if (feedAddress == address(0) || feedAddress == address(1)) {\\n            bytes32 feedId = r.priceFeedId;\\n            assembly { feedAddress := shr(96, feedId) }\\n            if (feedAddress == address(0) || feedAddress == address(1)) return (false, \"\");\\n        }\\n\\n        AggregatorV3Interface feed = AggregatorV3Interface(feedAddress);\\n        (uint80 latestRoundId, , , uint256 latestUpdatedAt, ) = feed.latestRoundData();\\n\\n        // Need at least one update after expiry to be resolvable\\n        if (latestUpdatedAt < r.expiryTimestamp) return (false, \"\");\\n\\n        // Avoid resolving extremely old markets via automation\\n        if (block.timestamp - latestUpdatedAt > 7 days) return (false, \"\");\\n\\n        // Pre-filter phase boundary cases to avoid likely revert in resolveAuto\\n        (, uint64 aggRound) = parseRoundId(latestRoundId);\\n        if (aggRound <= 1) return (false, \"\"); // wait for next update to avoid PhaseBoundaryRound revert\\n\\n        return (true, abi.encode(marketId));\\n    }\\n\\n    function performUpkeep(bytes calldata performData) external override {\\n        if (performData.length != 32) revert BadValue();\\n        uint256 marketId = abi.decode(performData, (uint256));\\n        resolveAuto(marketId);\\n    }\\n\\n    // =========================\\n    // Auto-resolve policy:\\n    // 1) FIRST update after expiry within SLA -> resolve(first)\\n    // 2) else if oracle has updates covering end of TWAP window -> resolve(TWAP [expiry, expiry+TWAP_WINDOW])\\n    // 3) else -> resolve(first) (late), because TWAP can't be anchored without an update after window end\\n    // =========================\\n\\n    function resolveAuto(uint256 marketId) public nonReentrant whenNotPaused {\\n        ICoreResolutionView.ResolutionConfig memory r = ICoreResolutionView(core).getMarketResolution(marketId);\\n\\n        if (r.isResolved) return;\\n        if (block.timestamp < r.expiryTimestamp) revert MarketNotExpired();\\n\\n        bool isChainlink = (r.oracleType == ICoreResolutionView.OracleType.ChainlinkFeed) ||\\n            (r.priceFeedId != bytes32(0) && (r.oracleAddress == address(0) || r.oracleAddress == address(1)));\\n        if (!isChainlink) revert NotChainlinkMarket();\\n\\n        address feedAddress = r.oracleAddress;\\n        if (feedAddress == address(0) || feedAddress == address(1)) {\\n            bytes32 feedId = r.priceFeedId;\\n            assembly { feedAddress := shr(96, feedId) }\\n            if (feedAddress == address(0) || feedAddress == address(1)) revert FeedMissing();\\n        }\\n\\n        AggregatorV3Interface feed = AggregatorV3Interface(feedAddress);\\n\\n        // decimals checks (same spirit as resolve())\\n        uint8 decNow = feed.decimals();\\n        if (decNow > 18) revert UnsupportedDecimals();\\n        if (r.oracleDecimals != 0 && decNow != r.oracleDecimals) {\\n            revert OracleDecimalsMismatch(r.oracleDecimals, decNow);\\n        }\\n\\n        // 1) first round after expiry\\n        (uint80 firstRid, uint256 firstUpdatedAt) = _firstRoundAfterTs(feed, r.expiryTimestamp, MAX_LOOKBACK_FIRST);\\n\\n        // 2) SLA path\\n        if (firstUpdatedAt <= r.expiryTimestamp + RESOLVE_SLA) {\\n            _resolveWithRound(marketId, firstRid);\\n            return;\\n        }\\n\\n        // 3) TWAP path only if we have an update after the end of the TWAP window (anchor)\\n        uint256 windowStart = r.expiryTimestamp;\\n        uint256 windowEnd = r.expiryTimestamp + TWAP_WINDOW;\\n\\n        (, , , uint256 latestUpdatedAt, ) = feed.latestRoundData();\\n        if (latestUpdatedAt < windowEnd) {\\n            // Can't compute TWAP [windowStart, windowEnd] reliably (no round after window end),\\n            // so fallback to first-after-expiry even though it's late.\\n            _resolveWithRound(marketId, firstRid);\\n            // _resolveWithRound emits MarketResolved; we add explicit \"late\" marker\\n            emit MarketResolvedLate(marketId, feedAddress, firstUpdatedAt);\\n            return;\\n        }\\n\\n        // Try TWAP computation with fallback to first-after-expiry if it fails (e.g., phase boundary)\\n        try this.computeTwapExternal(feedAddress, windowStart, windowEnd) returns (uint256 twapPrice1e18) {\\n            ICoreResolutionView(core).resolveMarketWithPrice(marketId, twapPrice1e18);\\n            emit MarketResolvedTwap(marketId, feedAddress, twapPrice1e18, windowStart, windowEnd);\\n        } catch {\\n            // TWAP failed (phase boundary / missing rounds) -> fallback to first-after-expiry\\n            _resolveWithRound(marketId, firstRid);\\n            emit MarketResolvedLate(marketId, feedAddress, firstUpdatedAt);\\n        }\\n    }\\n\\n    /**\\n     * @notice Find the first round whose updatedAt >= ts, and whose previous round updatedAt < ts\\n     * @dev Note: If the first round after expiry is round 1 of a new phase, this will revert with PhaseBoundaryRound.\\n     *      This is a rare edge case (phase transitions are infrequent). Manual resolution may be required.\\n     */\\n    function _firstRoundAfterTs(AggregatorV3Interface feed, uint256 ts, uint256 maxSteps)\\n        internal\\n        view\\n        returns (uint80 roundId, uint256 updatedAt)\\n    {\\n        (uint80 curRid, , , uint256 curUpdatedAt, ) = feed.latestRoundData();\\n        if (curUpdatedAt < ts) revert RoundTooEarly(curUpdatedAt, ts);\\n\\n        for (uint256 i = 0; i < maxSteps; i++) {\\n            (uint16 phase, uint64 aggRound) = parseRoundId(curRid);\\n            if (aggRound <= 1) revert PhaseBoundaryRound(); // Cannot verify previous round at phase boundary\\n\\n            uint80 prevRid = (uint80(phase) << 64) | (aggRound - 1);\\n\\n            try feed.getRoundData(prevRid) returns (uint80, int256, uint256, uint256 prevUpdatedAt, uint80) {\\n                if (prevUpdatedAt < ts) {\\n                    return (curRid, curUpdatedAt);\\n                }\\n                curRid = prevRid;\\n                curUpdatedAt = prevUpdatedAt;\\n            } catch {\\n                revert IncompleteRound();\\n            }\\n        }\\n\\n        revert IncompleteRound();\\n    }\\n\\n    /**\\n     * @notice External wrapper for TWAP computation (allows try/catch in resolveAuto)\\n     * @dev This is needed because internal functions cannot be caught with try/catch\\n     */\\n    function computeTwapExternal(address feedAddress, uint256 startTs, uint256 endTs)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        if (feedAddress == address(0) || feedAddress == address(1)) revert FeedMissing();\\n        return _computeTwap1e18(AggregatorV3Interface(feedAddress), startTs, endTs);\\n    }\\n\\n    /**\\n     * @notice Time-weighted average price (TWAP) over [startTs, endTs], normalized to 1e18\\n     * @dev Uses step function: previous round's price applies until current round's updatedAt\\n     *      Requires existence of a round after endTs to anchor the end boundary.\\n     */\\n    function _computeTwap1e18(\\n        AggregatorV3Interface feed,\\n        uint256 startTs,\\n        uint256 endTs\\n    ) internal view returns (uint256 twap1e18) {\\n        if (endTs <= startTs) revert BadValue();\\n\\n        (uint80 endRound, uint256 endRoundUpdatedAt) = _firstRoundAfterTs(feed, endTs, MAX_LOOKBACK_FIRST);\\n\\n        uint8 decNow = feed.decimals();\\n        if (decNow > 18) revert UnsupportedDecimals();\\n\\n        uint256 weightedSum = 0;\\n        uint256 totalDur = 0;\\n\\n        uint80 curRid = endRound;\\n        uint256 curUpdatedAt = endRoundUpdatedAt;\\n\\n        for (uint256 i = 0; i < MAX_LOOKBACK_TWAP; i++) {\\n            (uint16 phase, uint64 aggRound) = parseRoundId(curRid);\\n            if (aggRound <= 1) revert PhaseBoundaryRound();\\n\\n            uint80 prevRid = (uint80(phase) << 64) | (aggRound - 1);\\n\\n            (uint80 prid, int256 prevAnswer, , uint256 prevUpdatedAt, uint80 prevAnsweredInRound) = feed.getRoundData(prevRid);\\n            if (prevAnswer <= 0 || prevUpdatedAt == 0) revert InvalidAnswer();\\n            if (prevAnsweredInRound < prid) revert IncompleteRound();\\n\\n            uint256 segStart = prevUpdatedAt < startTs ? startTs : prevUpdatedAt;\\n            uint256 segEnd   = curUpdatedAt > endTs ? endTs : curUpdatedAt;\\n\\n            if (segEnd > segStart) {\\n                uint256 dur = segEnd - segStart;\\n\\n                uint256 raw = uint256(prevAnswer);\\n                uint256 p1e18;\\n                if (decNow == 18) {\\n                    p1e18 = raw;\\n                } else if (decNow < 18) {\\n                    p1e18 = raw * (10 ** (18 - decNow));\\n                } else {\\n                    p1e18 = raw / (10 ** (decNow - 18));\\n                }\\n\\n                weightedSum += p1e18 * dur;\\n                totalDur += dur;\\n            }\\n\\n            if (prevUpdatedAt <= startTs) break;\\n\\n            curRid = prevRid;\\n            curUpdatedAt = prevUpdatedAt;\\n        }\\n\\n        if (totalDur == 0) revert IncompleteRound();\\n        return weightedSum / totalDur;\\n    }\\n\\n    // =========================\\n    // Internal resolution logic (without nonReentrant to allow calls from resolveAuto)\\n    // =========================\\n\\n    function _resolveWithRound(uint256 marketId, uint80 roundId) internal {\\n        if (roundId == 0) revert InvalidRoundId();\\n\\n        (uint16 phase, uint64 aggregatorRound) = parseRoundId(roundId);\\n        if (aggregatorRound <= 1) revert PhaseBoundaryRound(); // Cannot verify previous round at phase boundary (round 0 or 1)\\n\\n        ICoreResolutionView.ResolutionConfig memory r = ICoreResolutionView(core).getMarketResolution(marketId);\\n\\n        bool isChainlink = (r.oracleType == ICoreResolutionView.OracleType.ChainlinkFeed) ||\\n            (r.priceFeedId != bytes32(0) && (r.oracleAddress == address(0) || r.oracleAddress == address(1)));\\n        if (!isChainlink) {\\n            revert NotChainlinkMarket();\\n        }\\n\\n        address feedAddress = r.oracleAddress;\\n        if (feedAddress == address(0) || feedAddress == address(1)) {\\n            bytes32 feedId = r.priceFeedId;\\n            assembly { feedAddress := shr(96, feedId) }\\n            if (feedAddress == address(0) || feedAddress == address(1)) {\\n                revert FeedMissing();\\n            }\\n        }\\n\\n        if (block.timestamp < r.expiryTimestamp) revert MarketNotExpired();\\n\\n        AggregatorV3Interface feed = AggregatorV3Interface(feedAddress);\\n\\n        // 1. Verify decimals if set\\n        uint8 decNow = feed.decimals();\\n        if (decNow > 18) revert UnsupportedDecimals();\\n        if (r.oracleDecimals != 0 && decNow != r.oracleDecimals) {\\n            revert OracleDecimalsMismatch(r.oracleDecimals, decNow);\\n        }\\n\\n        // 2. Fetch target round data\\n        (uint80 rid, int256 answer, , uint256 updatedAt, uint80 answeredInRound) = feed.getRoundData(roundId);\\n        if (answer <= 0 || updatedAt == 0) revert InvalidAnswer();\\n        if (answeredInRound < rid) revert IncompleteRound();\\n\\n        // 3. Verify target round is AFTER expiry\\n        if (updatedAt < r.expiryTimestamp) revert RoundTooEarly(updatedAt, r.expiryTimestamp);\\n\\n        // 4. Verify previous round was BEFORE expiry\\n        uint80 prevRoundId = (uint80(phase) << 64) | (aggregatorRound - 1);\\n\\n        try feed.getRoundData(prevRoundId) returns (uint80, int256, uint256, uint256 prevUpdatedAt, uint80) {\\n            if (prevUpdatedAt >= r.expiryTimestamp) {\\n                revert NotFirstRoundAfterExpiry(prevUpdatedAt, r.expiryTimestamp);\\n            }\\n        } catch {\\n            revert IncompleteRound();\\n        }\\n\\n        // 5. Staleness check (extremely old)\\n        uint256 maxAllowedAge = 7 days;\\n        if (block.timestamp - updatedAt > maxAllowedAge) {\\n            revert Stale(updatedAt, block.timestamp, maxAllowedAge);\\n        }\\n\\n        // 6. Normalize price to 1e18\\n        uint256 rawPrice = uint256(answer);\\n        uint256 normalizedPrice = decNow == 18\\n            ? rawPrice\\n            : (decNow < 18) ? rawPrice * (10 ** (18 - decNow)) : rawPrice / (10 ** (decNow - 18));\\n\\n        ICoreResolutionView(core).resolveMarketWithPrice(marketId, normalizedPrice);\\n\\n        emit MarketResolved(marketId, address(feed), normalizedPrice, updatedAt);\\n    }\\n\\n    // =========================\\n    // Manual / direct resolve using a specific roundId (public wrapper with nonReentrant)\\n    // =========================\\n\\n    function resolve(uint256 marketId, uint80 roundId) public nonReentrant whenNotPaused {\\n        _resolveWithRound(marketId, roundId);\\n    }\\n}\\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ]
      }
    }
  }
}